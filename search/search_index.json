{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pypst","text":"<p>Declarative Typst in Python with Pandas data frame support.</p> <p>Pypst helps you dynamically generate Typst code directly in Python. No manual string manipulation required. It has two major use cases:</p> <ul> <li>Generating full Typst documents to be rendered as PDFs</li> <li>Generating and styling Typst tables from Pandas data frames to be included in another Typst document</li> </ul> <p>Pypst produces human-readable Typst code that you can modify and extend. It will not compile Typst code for you, but you can either use the Typst compiler to do so in the command line or install the Typst Python package.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>Pypst is available on PyPI and can be installed via pip.</p> <pre><code>pip install pypst\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Pypst contains classes that represent Typst elements. You can create a Typst document by instantiating these classes and nesting them as needed.</p> <pre><code>&gt;&gt;&gt; import pypst\n&gt;&gt;&gt; heading = pypst.Heading(\"My Heading\", level=1)\n&gt;&gt;&gt; itemize = pypst.Itemize([\"First item\", \"Second item\", \"Third item\"])\n</code></pre> <p>Each of these classes has a <code>render</code> method that returns the Typst code as a string.</p> <pre><code>&gt;&gt;&gt; print(heading.render())\n= My Heading\n&gt;&gt;&gt; print(itemize.render())\n- First item\n- Second item\n- Third item\n</code></pre> <p>If you want to combine multiple elements into a single document, you can use the <code>Document</code> class. You can even add imports for other Typst files or packages.</p> <pre><code>&gt;&gt;&gt; document = pypst.Document([heading, itemize])\n&gt;&gt;&gt; document.add_import(\"utils.typ\")\n&gt;&gt;&gt; print(document.render())\n#import \"utils.typ\"\n\n= My Heading\n\n- First item\n- Second item\n- Third item\n</code></pre> <p>The output of the <code>render</code> method can be written to a <code>.typ</code> file for compilation. There are more extensive tutorials on generating documents and generating tables from Pandas data frames.</p>"},{"location":"#limitations","title":"Limitations","text":"<p>Pypst is not a Typst compiler. It doesn't check for syntax errors or compile Typst code into PDFs. Pypst interprets any string as a Typst literal, so <code>stroke = \"1pt\"</code> will be rendered as <code>stroke: 1pt</code>. If you want to pass a string literal, you need to wrap it in quotes, for example, <code>caption = '\"My Caption\"'</code>. When Pypst encounters a string wrapped in quotes without need, it will automatically remove them. For a content block, you can wrap the string in brackets instead, for example, <code>caption = \"[My content]\"</code>.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>If there is time and people are interested, I would like to add the following features:</p> <ul> <li> Complete table attributes (for example, <code>fill</code> is missing)</li> <li> Support automatic formating for common workflows, like automatically merging multi-level columns with mean and standard deviation</li> <li> Add more Typst elements (like headings or lists) to make building more complex documents easier</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Basic Usage</li> <li>Tables from Pandas</li> <li>API</li> </ul>"},{"location":"pandas/","title":"Create a Typst Table from a Pandas Data Frame","text":"<p>Pypst can create Typst tables from Pandas data frames. This allows you to use the full power of Pandas for data wrangling and then render the results in a Typst document. Multiple levels for columns and indexes are supported.</p>"},{"location":"pandas/#basics","title":"Basics","text":"<p>Create a data frame and do any data wrangling you need.</p> <pre><code>df = pd.DataFrame({\n    \"Name\": [\"Alice\", \"Bob\", \"Charlie\"],\n    \"Age\": [25, 30, 35],\n    \"City\": [\"New York\", \"Los Angeles\", \"New York\"]\n})\ndf = df.groupby(\"City\").agg({\"Name\": \"count\", \"Age\": \"mean\"})\n</code></pre> <p>Create a Typst table from the data frame and apply styling. Then wrap it in a figure and save it to a file.</p> <pre><code>table = pypst.Table.from_dataframe(df)\ntable.stroke = \"none\"\ntable.align = \"(x, _) =&gt; if calc.odd(x) {left} else {right}\"\ntable.add_hline(1, stroke=\"1.5pt\")\ntable.add_hline(len(df) + df.columns.nlevels, stroke=\"1.5pt\")\n\nfigure = pypst.Figure(table, caption='\"This is my table.\"')\n\nwith open(\"my-table.typ\", mode=\"wt\") as f:\n    f.write(figure.render())\n</code></pre> <p>The resulting file looks like this:</p> <pre><code>#figure(\n  table(\n    columns: 3,\n    stroke: none,\n    align: (x, _) =&gt; if calc.odd(x) {left} else {right},\n    table.hline(y: 1, stroke: 1.5pt),\n    table.hline(y: 3, stroke: 1.5pt),\n    table.header[][Name][Age],\n    [Los Angeles], [1], [30.0],\n    [New York], [2], [30.0]\n  ),\n  caption: \"This is my table.\"\n)\n</code></pre> <p>Include the file in your <code>main.typ</code> Typst document.</p> <pre><code>= My Section Heading\n\n#lorem(100)\n\n#include(\"my-table.typ\")\n\n#lorem(100)\n</code></pre> <p>Compile with <code>typst compile main.typ</code> to receive a PDF file like this. By using <code>typst watch main.typ</code>, you can automatically recompile the when your Python script runs.</p>"},{"location":"pandas/#styling-individual-cells","title":"Styling individual cells","text":"<p>You can style individual cells by accessing the <code>table.row_data</code> attribute. This attribute is a list of lists, where each sublist corresponds to a row in the table. Each sublist contains the data for the cells in that row.</p> <pre><code>table = pypst.Table.from_dataframe(df)\ntable.row_data[0][0].fill = \"red\"\ntable.row_data[1][1].fill = \"blue\"\n</code></pre> <p>The resulting Typst code looks like this:</p> <pre><code>#table(\n  columns: 3,\n  table.header[][Name][Age],\n  [#table.cell(fill: red)[Los Angeles]], [1], [30.0],\n  [New York], [#table.cell(fill: blue)[2]], [30.0]\n)\n</code></pre>"},{"location":"pandas/#using-third-party-packages","title":"Using Third-Party Packages","text":"<p>If your table uses third-party packages, you can wrap the figure in a document and include the proper imports.</p> <pre><code>document = pypst.Document(figure)\ndocument.add_import(\"@preview/unify:0.4.3\", [\"num\"])\n</code></pre> <p>The resulting file looks like this:</p> <pre><code>#import \"@preview/unify:0.4.3\": num\n\n#figure(\n  table(\n    columns: 3,\n    stroke: none,\n    align: (x, _) =&gt; if calc.odd(x) {left} else {right},\n    table.hline(y: 1, stroke: 1.5pt),\n    table.hline(y: 3, stroke: 1.5pt),\n    table.header[][Name][Age],\n    [Los Angeles], [1], [30.0],\n    [New York], [2], [30.0]\n  ),\n  caption: \"This is my table.\"\n)\n</code></pre>"},{"location":"pandas/#multiple-levels-for-columns-and-indexes","title":"Multiple Levels for Columns and Indexes","text":"<p>If your data frame has multiple levels for columns, Pypst will render them correctly.</p> <pre><code>df = pd.DataFrame(\n    [[1, 3], [2, 4]],\n    columns=pd.MultiIndex.from_tuples([(\"A\", \"mean\"), (\"A\", \"std\")]),\n    index=[\"X\", \"Y\"]\n)\ntable = pypst.Table.from_dataframe(df)\n</code></pre> <pre><code>#table(\n  columns: 3,\n  table.header[#table.cell(rowspan: 2)[]][#table.cell(colspan: 2)[A]][mean][std],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <p>Multiple levels for indexes are also supported.</p> <pre><code>df = pd.DataFrame(\n    [[1, 3], [2, 4]],\n    columns=[\"A\", \"B\"],\n    index=pd.MultiIndex.from_tuples([(\"X\", \"mean\"), (\"X\", \"std\")])\n)\ntable = Table.from_dataframe(df)\nprint(table.render())\n</code></pre> <pre><code>#table(\n  columns: 4,\n  table.header[#table.cell(colspan: 2)[]][A][B],\n  [#table.cell(rowspan: 2)[X]], [mean], [1], [3],\n  [std], [2], [4]\n)\n</code></pre> <p>The cells for the headers and row indexes are stored by level in the <code>table.header_data</code> and <code>table.index_data</code> attributes, respectively. You can access them to style the cells individually.</p>"},{"location":"usage/","title":"Usage","text":"<p>Pypst can be used to create Typst documents programmatically. This can be useful for generating reports, slides, or other documents directly in Python to avoid copy-pasting data. A full example can be found in the examples directory of the repository.</p>"},{"location":"usage/#basics","title":"Basics","text":"<p>Pypst contains classes that represent Typst elements. You can create a Typst document by instantiating these classes and nesting them as needed.</p> <pre><code>&gt;&gt;&gt; import pypst\n&gt;&gt;&gt; heading = pypst.Heading(\"My Heading\", level=1)\n&gt;&gt;&gt; itemize = pypst.Itemize([\"First item\", \"Second item\", \"Third item\"])\n</code></pre> <p>Each of these classes has a <code>render</code> method that returns the Typst code as a string.</p> <pre><code>&gt;&gt;&gt; print(heading.render())\n= My Heading\n&gt;&gt;&gt; print(itemize.render())\n- First item\n- Second item\n- Third item\n</code></pre> <p>If you want to combine multiple elements into a single document, you can use the <code>Document</code> class. You can even add imports for other Typst files or packages.</p> <pre><code>&gt;&gt;&gt; document = pypst.Document([heading, itemize])\n&gt;&gt;&gt; document.add_import(\"utils.typ\")\n&gt;&gt;&gt; print(document.render())\n#import \"utils.typ\"\n\n= My Heading\n\n- First item\n- Second item\n- Third item\n</code></pre> <p>The output of the <code>render</code> method can be written to a <code>.typ</code> file for compilation.</p>"},{"location":"usage/#dynamic-generation","title":"Dynamic Generation","text":"<p>You can use Python loops and conditionals to generate Typst elements. This can be useful for creating lists or other repetitive structures.</p> <pre><code>&gt;&gt;&gt; enum = pypst.Enumerate([])\n&gt;&gt;&gt; for i in range(1, 4):  # (1)!\n...     enum.add(f\"Item {i}\")\n&gt;&gt;&gt; print(enum.render())\n+ Item 1\n+ Item 2\n+ Item 3\n+ Item 4\n&gt;&gt;&gt; if len(enum.items) &gt; 3:  # (2)!\n...     doc.add(enum)\n</code></pre> <ol> <li>By using loops, you fill a list with your data. It may come from experiment results, database queries, or even API calls.</li> <li>Add elements conditionally, based on your data. This way you can include information about optional data only when it is available.</li> </ol>"},{"location":"usage/#including-figures","title":"Including Figures","text":"<p>You can include figures in your document by using the <code>Figure</code> class. The body of the figure can be any Typst element, but the most common, images and tables, are supported directly by Pypst.</p> <pre><code>&gt;&gt;&gt; figure = pypst.Figure(\"examples/example.png\", caption=\"Example script and output\")\n&gt;&gt;&gt; print(figure.render())\n#figure(\n  image(\"examples/example.png\"),\n  caption: \"Example script and output\"\n)\n</code></pre> <p>You can create images or plots with your favorite Python library and include them in your Typst document. Tables can be generated from Pandas data frames, as shown here.</p>"},{"location":"usage/#using-templates","title":"Using Templates","text":"<p>To use your own template or external ones, you can use a wrapper Typst file. Here is an example for using the IEEE template:</p> <pre><code>#import \"@preview/charged-ieee:0.1.0\": ieee\n\n#show: ieee.with(\n  title: [Using Templates with Pypst],\n  abstract: [#lorem(100)],\n  authors: (\n    (\n      name: \"Alice\",\n      department: [Co-Author],\n      organization: [Best University],\n      email: \"alice@university.org\"\n    ),\n    (\n      name: \"Bob\",\n      department: [Co-Author],\n      organization: [Best University],\n      email: \"bob@university.com\"\n    ),\n  ),\n  index-terms: (\"Scientific writing\", \"Typesetting\", \"Document creation\", \"Syntax\")\n)\n\n// include generated file\n#include(\"my-document.typ\")\n</code></pre> <p>The wrapper file imports and sets up the template. It then includes the generated file created with Pypst.</p>"},{"location":"usage/#what-about-show-and-set-rules","title":"What about show and set rules?","text":"<p>Pypst doesn't support the <code>show</code> and <code>set</code> rules by design. We think it is easier to set up your global rules in a template file and then include your generated document, like shown above. Generating dynamic rules doesn't seem like a common use case. If you still want to include rules, you can always add them as a string to your document.</p> <pre><code>&gt;&gt;&gt; document.add(\"#set: text(size: 12pt)\")\n</code></pre>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cell</li> <li>document</li> <li>figure</li> <li>heading</li> <li>image</li> <li>itemize</li> <li>renderable</li> <li>table</li> <li>utils</li> </ul>"},{"location":"api/pypst/cell/","title":"cell","text":""},{"location":"api/pypst/cell/#pypst.cell.Cell","title":"<code>Cell</code>","text":"<p>A cell element that can be rendered as a table cell.</p> <p>Normally, the user does not need to create a cell directly. When creating a table from a data frame, the table will automatically create cells. These cells can then be modified to style them individually.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[Any]</code> <p>The content of the cell.</p> <code>None</code> <code>rowspan</code> <code>int</code> <p>The number of rows the cell spans.</p> <code>1</code> <code>colspan</code> <code>int</code> <p>The number of columns the cell spans.</p> <code>1</code> <code>fill</code> <code>Optional[str]</code> <p>The background color of the cell.</p> <code>None</code> <code>align</code> <code>Optional[str]</code> <p>The alignment of the cell content.</p> <code>None</code> <code>stroke</code> <code>Optional[str | list | dict]</code> <p>The stroke style of the cell.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cell = Cell(\n...     \"Value\",\n...     rowspan=2,\n...     colspan=3,\n...     fill=\"red\",\n...     align=\"center\",\n...     stroke=\"black\"\n... )\n&gt;&gt;&gt; print(cell)\n[#table.cell(rowspan: 2, colspan: 3, fill: red, align: center, stroke: black)[Value]]\n</code></pre>"},{"location":"api/pypst/cell/#pypst.cell.Cell.render","title":"<code>render()</code>","text":"<p>Render the cell to string.</p> <p>The cell function is surrounded by a content block to fit the table syntax.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered cell.</p>"},{"location":"api/pypst/document/","title":"document","text":""},{"location":"api/pypst/document/#pypst.document.Document","title":"<code>Document</code>","text":"<p>Represents a Typst document serving as the top-level container.</p> <p>A document contains other renderable objects and necessary imports. It is only necessary if multiple renderable objects need to be combined or third-party files need to be imported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; doc = Document(\"Hello, world!\")\n&gt;&gt;&gt; print(doc.render())\nHello, world!\n</code></pre> <pre><code>&gt;&gt;&gt; doc = Document([\"Hello,\", \"world!\"])\n&gt;&gt;&gt; print(doc.render())\nHello,\n\nworld!\n</code></pre> <pre><code>&gt;&gt;&gt; doc = Document()\n&gt;&gt;&gt; doc.add(\"Hello,\")\n&gt;&gt;&gt; doc.add(\"world!\")\n&gt;&gt;&gt; print(doc.render())\nHello,\n\nworld!\n</code></pre> <pre><code>&gt;&gt;&gt; doc = Document()\n&gt;&gt;&gt; doc.add_import(\"module\")\n&gt;&gt;&gt; doc.add(\"Hello, world!\")\n&gt;&gt;&gt; print(doc.render())\n#import \"module\"\n\nHello, world!\n</code></pre>"},{"location":"api/pypst/document/#pypst.document.Document.body","title":"<code>body: list[Renderable | str]</code>  <code>property</code>","text":"<p>The body of the document.</p>"},{"location":"api/pypst/document/#pypst.document.Document.__init__","title":"<code>__init__(body=None)</code>","text":"<p>Create a new document with an optional body.</p> <p>The body can be a single renderable object, a string, or a list of renderable objects and strings.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Optional[Renderable | str | list[Renderable | str]]</code> <p>The body of the document.</p> <code>None</code>"},{"location":"api/pypst/document/#pypst.document.Document.add","title":"<code>add(element)</code>","text":"<p>Add a body element to the document.</p> <p>Any object of the <code>pypst</code> library with a <code>render</code> method can be added. Simple text paragraphs or unsupported Typst elements can be added as strings. Adding an <code>Import</code> object is equivalent to calling <code>add_import</code>.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Renderable | str</code> <p>The new body element.</p> required"},{"location":"api/pypst/document/#pypst.document.Document.add_import","title":"<code>add_import(module, members=None)</code>","text":"<p>Add an import to the document.</p> <p>If members are provided, only those members will be imported as <code>#import &lt;module&gt;: &lt;list of members&gt;</code>. If no members are provided, the entire module will be imported as <code>#import &lt;module&gt;</code>. Imports are rendered at the top of the document.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>str</code> <p>The module to import.</p> required <code>members</code> <code>Optional[list[str]]</code> <p>The optional list of members to import.</p> <code>None</code>"},{"location":"api/pypst/document/#pypst.document.Document.render","title":"<code>render()</code>","text":"<p>Render the document.</p> <p>The rendered document has all imports at the top followed by the body. Each element in the body is rendered in the order it was added. A blank line separates each body element.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered document string.</p>"},{"location":"api/pypst/figure/","title":"figure","text":""},{"location":"api/pypst/figure/#pypst.figure.Figure","title":"<code>Figure</code>  <code>dataclass</code>","text":"<p>A figure is a block element that contains another element.</p> <p>It can be used to add captions, numbering, and other metadata to the element.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Renderable | str</code> <p>The element to be rendered inside the figure.</p> required <code>placement</code> <code>Optional[Literal['auto', 'top', 'bottom']]</code> <p>The placement of the figure.</p> <code>None</code> <code>caption</code> <code>Optional[str]</code> <p>The caption of the figure.</p> <code>None</code> <code>kind</code> <code>Optional[str]</code> <p>The kind of the figure.</p> <code>None</code> <code>supplement</code> <code>Optional[str]</code> <p>The supplement of the figure added when the figure is referenced.</p> <code>None</code> <code>numbering</code> <code>Optional[str]</code> <p>The numbering scheme of the figure.</p> <code>None</code> <code>gap</code> <code>Optional[str]</code> <p>The gap between body and caption.</p> <code>None</code> <code>outlined</code> <code>Optional[bool]</code> <p>Whether the figure is added to the outline.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = Figure(\"[Hello, World!]\", caption=\"[This is content.]\")\n&gt;&gt;&gt; print(fig.render())\n#figure(\n  [Hello, World!],\n  caption: [This is content.]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; from pypst import Image\n&gt;&gt;&gt; fig = Figure(Image(\"image.png\"), caption=\"[This is an image.]\")\n&gt;&gt;&gt; print(fig.render())\n#figure(\n  image(\"image.png\"),\n  caption: [This is an image.]\n)\n</code></pre>"},{"location":"api/pypst/figure/#pypst.figure.Figure.render","title":"<code>render()</code>","text":"<p>Render the figure.</p> <p>The body and attributes of the figure is indented by two spaces.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered figure.</p>"},{"location":"api/pypst/heading/","title":"heading","text":""},{"location":"api/pypst/heading/#pypst.heading.Heading","title":"<code>Heading</code>  <code>dataclass</code>","text":"<p>A Heading element.</p> <p>If only the body and level are provided, the heading will be rendered as in Markdown. If any other attribute is provided, the heading will be rendered as a function.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Renderable | str</code> <p>The content of the heading.</p> required <code>level</code> <code>Optional[int]</code> <p>The absolute nesting depth of the heading, starting from one.</p> <code>None</code> <code>depth</code> <code>Optional[int]</code> <p>The relative nesting depth of the heading, starting from one.</p> <code>None</code> <code>offset</code> <code>Optional[int]</code> <p>The starting offset of each heading's level,     used to turn its relative depth into its absolute level.</p> <code>None</code> <code>numbering</code> <code>Optional[str]</code> <p>The numbering scheme, for example, <code>\"1.1\"</code>.</p> <code>None</code> <code>supplement</code> <code>Optional[Renderable | str]</code> <p>The supplement for the heading.</p> <code>None</code> <code>outlined</code> <code>Optional[bool]</code> <p>Whether the heading appears in the outline.</p> <code>None</code> <code>bookmarked</code> <code>Optional[bool]</code> <p>Whether the heading appears as a bookmark in PDF.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; h = Heading(\"Heading 1\", level=1)\n&gt;&gt;&gt; print(h.render())\n= Heading 1\n</code></pre> <pre><code>&gt;&gt;&gt; h = Heading(\"Heading 1\", level=3)\n&gt;&gt;&gt; print(h.render())\n=== Heading 1\n</code></pre> <pre><code>&gt;&gt;&gt; h = Heading('\"Heading 1\"', depth=2, offset=1)\n&gt;&gt;&gt; print(h.render())\n#heading(\"Heading 1\", depth: 2, offset: 1)\n</code></pre>"},{"location":"api/pypst/heading/#pypst.heading.Heading.render","title":"<code>render()</code>","text":"<p>Render the heading to a string.</p> <p>If only body and level are provided, the heading will be rendered as in Markdown. If any other attribute is provided, the heading will be rendered as a function.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered heading element.</p>"},{"location":"api/pypst/image/","title":"image","text":""},{"location":"api/pypst/image/#pypst.image.Image","title":"<code>Image</code>  <code>dataclass</code>","text":"<p>Image object to add image elements.</p> <p>The image file needs to be in the provided path. The path is interpreted as relative to the Typst file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the image file.</p> required <code>format</code> <code>Optional[Literal['png', 'jpg', 'gif', 'svg']]</code> <p>The image format.</p> <code>None</code> <code>width</code> <code>Optional[str]</code> <p>The width the image should occupy.</p> <code>None</code> <code>height</code> <code>Optional[str]</code> <p>The height the image should occupy.</p> <code>None</code> <code>alt</code> <code>Optional[str]</code> <p>The image alt text.</p> <code>None</code> <code>fit</code> <code>Optional[Literal['cover', 'contain', 'stretch']]</code> <p>How the image fills the space defined by <code>width</code> and <code>height</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; image = Image(path=\"image.png\", width=\"100%\", height=\"50%\")\n&gt;&gt;&gt; print(image.render())\n#image(\"image.png\", width: 100%, height: 50%)\n</code></pre>"},{"location":"api/pypst/image/#pypst.image.Image.render","title":"<code>render()</code>","text":"<p>Render the image element to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered image element.</p>"},{"location":"api/pypst/itemize/","title":"itemize","text":""},{"location":"api/pypst/itemize/#pypst.itemize.Enumerate","title":"<code>Enumerate</code>  <code>dataclass</code>","text":"<p>An element that represents a numbered list.</p> <p>If no arguments are provided, the list will be rendered as a Markdown list. Otherwise, the list will be rendered as a function. It is possible to nest lists in both Markdown and functional forms.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>list[Renderable | str]</code> <p>List of elements to be rendered as numbered points.</p> required <code>tight</code> <code>Optional[bool]</code> <p>Whether to use list or leading spacing between elements.</p> <code>None</code> <code>numbering</code> <code>Optional[str]</code> <p>The numbering scheme to use.</p> <code>None</code> <code>start</code> <code>Optional[int]</code> <p>The starting number for the list.</p> <code>None</code> <code>full</code> <code>Optional[bool]</code> <p>Whether to use full numbering with parent enumerations.</p> <code>None</code> <code>indent</code> <code>Optional[str]</code> <p>The indent for each element.</p> <code>None</code> <code>body_indent</code> <code>Optional[str]</code> <p>The spacing between the number and the element body.</p> <code>None</code> <code>spacing</code> <code>Optional[str]</code> <p>The spacing of a non-tight list.</p> <code>None</code> <code>number_align</code> <code>Optional[str]</code> <p>The alignment of the numbers.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; enumerate = Enumerate([\"First\", \"Second\"])\n&gt;&gt;&gt; print(enumerate.render())\n+ First\n+ Second\n</code></pre> <pre><code>&gt;&gt;&gt; enumerate = Enumerate([\"First\", Enumerate([\"Nested 1\", \"Nested 2\"]), \"Second\"])\n&gt;&gt;&gt; print(enumerate.render())\n+ First\n  + Nested 1\n  + Nested 2\n+ Second\n</code></pre> <pre><code>&gt;&gt;&gt; enumerate = Enumerate([\"First\", Itemize([\"Nested 1\", \"Nested 2\"]), \"Second\"])\n&gt;&gt;&gt; print(enumerate.render())\n+ First\n  - Nested 1\n  - Nested 2\n+ Second\n</code></pre> <pre><code>&gt;&gt;&gt; enumerate = Enumerate([])\n&gt;&gt;&gt; enumerate.add(\"First\")\n&gt;&gt;&gt; enumerate.add(\"Second\")\n&gt;&gt;&gt; print(enumerate.render())\n+ First\n+ Second\n</code></pre>"},{"location":"api/pypst/itemize/#pypst.itemize.Enumerate.add","title":"<code>add(element)</code>","text":"<p>Add an element to the numbered list.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Renderable | str</code> <p>The new element.</p> required"},{"location":"api/pypst/itemize/#pypst.itemize.Enumerate.render","title":"<code>render()</code>","text":"<p>Render the numbered list to string.</p> <p>If any arguments are provided, the list will be rendered as a function. Otherwise, the list will be rendered as a Markdown list.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered numbered list.</p>"},{"location":"api/pypst/itemize/#pypst.itemize.Itemize","title":"<code>Itemize</code>  <code>dataclass</code>","text":"<p>An element that represents a bullet point list.</p> <p>If no arguments are provided, the list will be rendered as a Markdown list. Otherwise, the list will be rendered as a function. It is possible to nest lists in both Markdown and functional forms.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>list[Renderable | str]</code> <p>List of elements to be rendered as bullet points.</p> required <code>tight</code> <code>Optional[bool]</code> <p>Whether to use list or leading spacing between elements.</p> <code>None</code> <code>marker</code> <code>Optional[str | list[str]]</code> <p>The bullet point markers to use.</p> <code>None</code> <code>indent</code> <code>Optional[str]</code> <p>The indent for each element.</p> <code>None</code> <code>body_indent</code> <code>Optional[str]</code> <p>The spacing between the marker and the element body.</p> <code>None</code> <code>spacing</code> <code>Optional[str]</code> <p>The spacing of a non-tight list.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itemize = Itemize([\"First\", \"Second\"])\n&gt;&gt;&gt; print(itemize.render())\n- First\n- Second\n</code></pre> <pre><code>&gt;&gt;&gt; itemize = Itemize([\"First\", \"Second\"], tight=True)\n&gt;&gt;&gt; print(itemize.render())\n#list(\n  tight: true,\n  [First],\n  [Second]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; itemize = Itemize([\"First\", Itemize([\"Nested 1\", \"Nested 2\"]), \"Second\"])\n&gt;&gt;&gt; print(itemize.render())\n- First\n  - Nested 1\n  - Nested 2\n- Second\n</code></pre> <pre><code>&gt;&gt;&gt; enumerate = Itemize([\"First\", Enumerate([\"Nested 1\", \"Nested 2\"]), \"Second\"])\n&gt;&gt;&gt; print(enumerate.render())\n- First\n  + Nested 1\n  + Nested 2\n- Second\n</code></pre> <pre><code>&gt;&gt;&gt; itemize = Itemize([])\n&gt;&gt;&gt; itemize.add(\"First\")\n&gt;&gt;&gt; itemize.add(\"Second\")\n&gt;&gt;&gt; print(itemize.render())\n- First\n- Second\n</code></pre>"},{"location":"api/pypst/itemize/#pypst.itemize.Itemize.add","title":"<code>add(element)</code>","text":"<p>Add an element to the bullet point list.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Renderable | str</code> <p>The new element.</p> required"},{"location":"api/pypst/itemize/#pypst.itemize.Itemize.render","title":"<code>render()</code>","text":"<p>Render the bullet point list to string.</p> <p>If any arguments are provided, the list will be rendered as a function. Otherwise, the list will be rendered as a Markdown list.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered list.</p>"},{"location":"api/pypst/renderable/","title":"renderable","text":""},{"location":"api/pypst/table/","title":"table","text":""},{"location":"api/pypst/table/#pypst.table.Table","title":"<code>Table</code>  <code>dataclass</code>","text":"<p>A table element.</p> <p>A table is constructed from a pandas DataFrame using the from_dataframe method. Afterward, styling options can be set using the properties of the class. Manual horizontal and vertical lines can be added using the <code>add_hline</code> and <code>add_vline</code> methods.</p> <p>Most properties that accept a string also accept functions in Typst. Typst functions can be supplied in string form, for example, <code>\"(x, y) =&gt; if x &gt; y then {red} else {black}\"</code>.</p> Hint <p>The header, index and row data can be accessed via the <code>header_data</code>, <code>index_data</code> and <code>row_data</code> properties. The lists can't be modified directly, but the elements can be accessed to apply styling to individual cells.</p>"},{"location":"api/pypst/table/#pypst.table.Table.align","title":"<code>align: Optional[str | FrozenList[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>The alignment for the table columns.</p> <p>This can be either a string to align all columns, or a list of strings to align individual columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.align = \"right\"\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  align: right,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.align = [\"left\", \"center\", \"right\"]  # two columns plus index\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  align: (left, center, right),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.column_gutter","title":"<code>column_gutter: Optional[int | str | FrozenList[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>The spacing between table columns.</p> <p>This can be either an integer/string to set the column gutter for all columns, or a list of strings to set the column gutter for individual columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.column_gutter = 10\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  column-gutter: 10,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.column_gutter = [\"10pt\", \"20pt\", \"30pt\"]  # two columns plus index\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  column-gutter: (10pt, 20pt, 30pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.columns","title":"<code>columns: Optional[int | str | FrozenList[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>The number of columns or column styling array.</p> <p>This property is automatically set when creating a table from a DataFrame. It can be replaced by an integer to apply styling to all columns or by a list to apply styling to individual columns.</p> <p>If a list is provided, it must have the same length as the number of columns plus the number of index levels.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.columns = \"50%\"\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 50%,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.columns = [\"10pt\", \"20pt\", \"30pt\"] # two columns plus index\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: (10pt, 20pt, 30pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.fill","title":"<code>fill: Optional[str | FrozenList[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>The background color for the table cells.</p> <p>This can be either a string to fill all cells, or a list of strings to fill individual columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.fill = \"red\"\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  fill: red,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.fill = [\"red\", \"blue\", \"green\"]  # two columns plus index\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  fill: (red, blue, green),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.gutter","title":"<code>gutter: Optional[int | str | FrozenList[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>The spacing between table cells.</p> <p>This can be either an integer/string to set the gutter for all cells, or a list of strings to set the gutter for individual columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.gutter = 10\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  gutter: 10,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.gutter = [\"10pt\", \"20pt\", \"30pt\"]  # two columns plus index\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  gutter: (10pt, 20pt, 30pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.row_gutter","title":"<code>row_gutter: Optional[int | str | FrozenList[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>The spacing between table rows.</p> <p>This can be either an integer/string to set the row gutter for all cells, or a list of strings to set the row gutter for individual columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.row_gutter = 10\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  row-gutter: 10,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.row_gutter = [\"10pt\", \"20pt\", \"30pt\"]  # two columns plus index\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  row-gutter: (10pt, 20pt, 30pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.rows","title":"<code>rows: Optional[int | str | FrozenList[str]]</code>  <code>property</code> <code>writable</code>","text":"<p>The number of rows or row styling array.</p> <p>This property is automatically set when creating a table from a DataFrame. It can be replaced by an integer to apply styling to all rows or by a list to apply styling to individual rows.</p> <p>If a list is provided, it must have the same length as the number of rows plus the number of header levels.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.rows = \"50%\"\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  rows: 50%,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.rows = [\"10pt\", \"20pt\", \"30pt\"] # two rows plus header\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  rows: (10pt, 20pt, 30pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.stroke","title":"<code>stroke: Optional[str | FrozenList[str] | frozendict[str, str]]</code>  <code>property</code> <code>writable</code>","text":"<p>The stroke style for the table cells.</p> <p>This can be either a string to style all cells, a list of strings to style each column, or a dictionary to control the stroke of each of the cells' sides.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.stroke = \"2pt\"\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  stroke: 2pt,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.stroke = [\"2pt\", \"1pt\", \"3pt\"]\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  stroke: (2pt, 1pt, 3pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.stroke = {\"top\": \"2pt\", \"bottom\": \"1pt\"}\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  stroke: (top: 2pt, bottom: 1pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.add_hline","title":"<code>add_hline(y, start=None, end=None, stroke=None, position=None)</code>","text":"<p>Add a horizontal line to the table at the specified row position.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>int</code> <p>The row position.</p> required <code>start</code> <code>Optional[int]</code> <p>The column to start the line.</p> <code>None</code> <code>end</code> <code>Optional[int]</code> <p>The column to end the line.</p> <code>None</code> <code>stroke</code> <code>Optional[str]</code> <p>The stroke style for the line.</p> <code>None</code> <code>position</code> <code>Optional[Literal['start', 'end']]</code> <p>Whether the line should appear before or after the row.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.add_hline(1, stroke=\"2pt\")\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  table.hline(y: 1, stroke: 2pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.add_vline","title":"<code>add_vline(x, start=None, end=None, stroke=None, position=None)</code>","text":"<p>Add a vertical line to the table at the specified column position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The column position.</p> required <code>start</code> <code>Optional[int]</code> <p>The row to start the line.</p> <code>None</code> <code>end</code> <code>Optional[int]</code> <p>The row to end the line.</p> <code>None</code> <code>stroke</code> <code>Optional[str]</code> <p>The stroke style for the line.</p> <code>None</code> <code>position</code> <code>Optional[Literal['start', 'end']]</code> <p>Whether the line should appear before or after the column.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; table.add_vline(1, stroke=\"2pt\")\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  table.vline(x: 1, stroke: 2pt),\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre>"},{"location":"api/pypst/table/#pypst.table.Table.from_dataframe","title":"<code>from_dataframe(df)</code>  <code>classmethod</code>","text":"<p>Create a new table element from a Pandas DataFrame.</p> <p>The <code>columns</code> property of the data frame will be used as the header data and the <code>index</code> property will be used as the index data. The header is rendered as the <code>table.header</code> element and the index as the first columns in each row. Multi-level indexes are supported.</p> <p>After creating the table, styling options can be set using the properties of the table class.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to create the table from.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}, index=[\"X\", \"Y\"])\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  table.header[][A][B],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(\n...     [[1, 3], [2, 4]],\n...     columns=pd.MultiIndex.from_tuples([(\"A\", \"mean\"), (\"A\", \"std\")]),\n...     index=[\"X\", \"Y\"]\n... )\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 3,\n  table.header[#table.cell(rowspan: 2)[]][#table.cell(colspan: 2)[A]][mean][std],\n  [X], [1], [3],\n  [Y], [2], [4]\n)\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(\n...     [[1, 3], [2, 4]],\n...     columns=[\"A\", \"B\"],\n...     index=pd.MultiIndex.from_tuples([(\"X\", \"mean\"), (\"X\", \"std\")])\n... )\n&gt;&gt;&gt; table = Table.from_dataframe(df)\n&gt;&gt;&gt; print(table.render())\n#table(\n  columns: 4,\n  table.header[#table.cell(colspan: 2)[]][A][B],\n  [#table.cell(rowspan: 2)[X]], [mean], [1], [3],\n  [std], [2], [4]\n)\n</code></pre> <p>Returns:</p> Type Description <code>Table</code> <p>The new table element.</p>"},{"location":"api/pypst/table/#pypst.table.Table.render","title":"<code>render()</code>","text":"<p>Render the table element to a string.</p> <p>Vertical and horizontal lines are rendered before the table body. All attributes and the body are indented by two spaces.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered table element.</p>"},{"location":"api/pypst/utils/","title":"utils","text":""}]}